<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ü–æ–ª–∏–º–µ—Ä, –∫–æ–≥–¥–∞ –≤–∏–¥–µ–æ? - OnCube</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="moving-gradient" id="gradient1"></div>
    <div class="moving-gradient" id="gradient2"></div>
    <div class="moving-gradient" id="gradient3"></div>
    
    <div class="content">
        <div class="glass-row">
            <div class="glass-card main">
                <h2>–° –º–æ–º–µ–Ω—Ç–∞ –≤—ã—Ö–æ–¥–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–∏–¥–µ–æ PolimerS –ø—Ä–æ—à–ª–æ:</h2>
                <div id="timer" class="timer-display">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
            </div>
        </div>

        <div class="platform-photo-wrapper">
            <img src="../resources/plat-photo.png" alt="–ü–æ–ª–∏–º–µ—Ä –∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞" class="platform-photo">
            <div class="platform-photo-caption">—Ñ–æ—Ç–æ –æ—Ç 7 —è–Ω–≤–∞—Ä—è 2026 –≥–æ–¥–∞</div>
        </div>

        <div class="secondary-timer">
            <div class="secondary-timer-label">–î–æ 12 —è–Ω–≤–∞—Ä—è 2026 –≥–æ–¥–∞ –æ—Å—Ç–∞–ª–æ—Å—å:</div>
            <div id="secondary-timer" class="timer-display secondary">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
        </div>
    </div>

    <button id="back-btn" class="back-btn" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é" onclick="window.location.href='/'">‚¨Ö</button>
    
    <footer class="footer-note">
        <div style="color:#888;">
            –í—Å–µ –ø—Ä–∞–≤–∞ –Ω–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç <a href="https://github.com/oncube-dev" target="_blank" style="text-decoration:underline; color:#f59e0b">OnCube</a> ‚ãÖ –°–∞–π—Ç —Å–¥–µ–ª–∞–ª–∏ <a href="https://youtube.com/@PolimerS" target="_blank" style="color:#f59e0b">PoliSours</a> & <a href="https://vobi.bio.link" target="_blank" style="color:#f59e0b">Vobi</a> —Å –ª—é–±–æ–≤—å—é üß°
        </div>
        <div style="font-size:0.85em; color:#888; margin-top:13px; font-style: italic;">
            [2025-2026] ¬© Source available project licensed under Business Source License 1.1 ‚Äî Modified Edition. All rights reserved.
        </div>
    </footer>

    <script src="info_script.js?v=3"></script>
    <script>
        let startDate = null;
        const secondaryEndDate = new Date('2026-01-12T13:00:00');
        let secondaryInterval = null;

        async function fetchLastVideoDate() {
            try {
                const apiUrl = `https://www.googleapis.com/youtube/v3/search?key=${API_KEY}&channelId=${CHANNEL_ID}&part=snippet,id&order=date&maxResults=1`;
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        throw new Error('API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤');
                    } else {
                        throw new Error(`–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ YouTube API: ${response.status}`);
                    }
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(`YouTube API –æ—à–∏–±–∫–∞: ${data.error.message}`);
                }
                
                const video = data.items && data.items[0];
                if (video && video.snippet && video.snippet.publishedAt) {
                    startDate = new Date(video.snippet.publishedAt);
                } else {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞—Ç—É –≤–∏–¥–µ–æ');
                }
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ YouTube API:', e);
                
                
                const fallbackDate = new Date('2025-12-23T12:00:00Z');
                startDate = fallbackDate;
                
                console.log('–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –¥–∞—Ç–∞:', fallbackDate.toISOString());
                document.getElementById('timer').textContent = '–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –¥–∞—Ç–∞';
                
                
                setTimeout(() => {
                    document.getElementById('timer').textContent = '–¢–∞–π–º–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –¥–∞—Ç—ã';
                }, 2000);
                
                
                console.log('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏ API:', {
                    message: e.message,
                    status: e.message.includes('403') ? '403 Forbidden' : 'Unknown',
                    suggestion: '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á –≤ Google Cloud Console',
                    apiKey: API_KEY.substring(0, 10) + '...',
                    channelId: CHANNEL_ID,
                    timestamp: new Date().toISOString()
                });
            }
        }

        function plural(n, one, two, five) {
            n = Math.abs(n) % 100;
            let n1 = n % 10;
            if (n > 10 && n < 20) return five;
            if (n1 > 1 && n1 < 5) return two;
            if (n1 == 1) return one;
            return five;
        }

        function updateTimer() {
            if (!startDate) return;
            const now = new Date();
            let diff = now - startDate;
            if (diff < 0) diff = 0;
            let seconds = Math.floor(diff / 1000);
            const days = Math.floor(seconds / (24 * 3600));
            seconds %= 24 * 3600;
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;
            const daysText = plural(days, '–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π');
            const hoursText = plural(hours, '—á–∞—Å', '—á–∞—Å–∞', '—á–∞—Å–æ–≤');
            const minutesText = plural(minutes, '–º–∏–Ω—É—Ç–∞', '–º–∏–Ω—É—Ç—ã', '–º–∏–Ω—É—Ç');
            const secondsText = plural(seconds, '—Å–µ–∫—É–Ω–¥–∞', '—Å–µ–∫—É–Ω–¥—ã', '—Å–µ–∫—É–Ω–¥');
            document.getElementById('timer').textContent = `${days} ${daysText} ${hours} ${hoursText} ${minutes} ${minutesText} ${seconds} ${secondsText}`;
        }

        function updateSecondaryTimer() {
            const el = document.getElementById('secondary-timer');
            if (!el) return;

            const now = new Date();
            let diff = secondaryEndDate - now;

            if (diff <= 0) {
                clearInterval(secondaryInterval);
                const zero = '0';
                const daysText = plural(0, '–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π');
                const hoursText = plural(0, '—á–∞—Å', '—á–∞—Å–∞', '—á–∞—Å–æ–≤');
                const minutesText = plural(0, '–º–∏–Ω—É—Ç–∞', '–º–∏–Ω—É—Ç—ã', '–º–∏–Ω—É—Ç');
                const secondsText = plural(0, '—Å–µ–∫—É–Ω–¥–∞', '—Å–µ–∫—É–Ω–¥—ã', '—Å–µ–∫—É–Ω–¥');
                el.textContent = `${zero} ${daysText} ${zero} ${hoursText} ${zero} ${minutesText} ${zero} ${secondsText}`;
                return;
            }

            let seconds = Math.floor(diff / 1000);
            const days = Math.floor(seconds / (24 * 3600));
            seconds %= 24 * 3600;
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;

            const daysText = plural(days, '–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π');
            const hoursText = plural(hours, '—á–∞—Å', '—á–∞—Å–∞', '—á–∞—Å–æ–≤');
            const minutesText = plural(minutes, '–º–∏–Ω—É—Ç–∞', '–º–∏–Ω—É—Ç—ã', '–º–∏–Ω—É—Ç');
            const secondsText = plural(seconds, '—Å–µ–∫—É–Ω–¥–∞', '—Å–µ–∫—É–Ω–¥—ã', '—Å–µ–∫—É–Ω–¥');

            el.textContent = `${days} ${daysText} ${hours} ${hoursText} ${minutes} ${minutesText} ${seconds} ${secondsText}`;
        }

        async function initTimer() {
            document.getElementById('timer').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞—Ç—ã –≤–∏–¥–µ–æ...';
            await fetchLastVideoDate();
            if (startDate) {
                updateTimer();
                setInterval(updateTimer, 1000);
            }

            const secondaryEl = document.getElementById('secondary-timer');
            if (secondaryEl) {
                secondaryEl.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–∞–π–º–µ—Ä–∞...';
                updateSecondaryTimer();
                secondaryInterval = setInterval(updateSecondaryTimer, 1000);
            }
        }
        initTimer();

        
        function createDynamicGradients() {
            const gradients = [
                document.getElementById('gradient1'),
                document.getElementById('gradient2'),
                document.getElementById('gradient3')
            ];

            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                gradients[1].style.display = 'none';
                gradients[2].style.display = 'none';
            }

            let time = 0;
            let lastTime = 0;
            const frameRate = isMobile ? 30 : 60;
            const frameInterval = 1000 / frameRate;

            function interpolateColor(color1, color2, factor) {
                return {
                    r: Math.round(color1.r + (color2.r - color1.r) * factor),
                    g: Math.round(color1.g + (color2.g - color1.g) * factor),
                    b: Math.round(color1.b + (color2.b - color1.b) * factor)
                };
            }

            function updateGradients(currentTime) {
                if (isMobile && currentTime - lastTime < frameInterval) {
                    requestAnimationFrame(updateGradients);
                    return;
                }
                lastTime = currentTime;

                time += isMobile ? 0.002 : 0.005;
                
                gradients.forEach((gradient, index) => {
                    if (isMobile && index > 0) return;
                    
                    const phase = time + index * Math.PI / 3;
                    
                    const orange = { r: 255, g: 165, b: 0 };
                    const purple = { r: 147, g: 51, b: 234 };
                    
                    const transition = (Math.sin(phase * 0.5) + 1) / 2;
                    const currentColor = interpolateColor(orange, purple, transition);
                    const oppositeColor = interpolateColor(purple, orange, transition);
                    
                    const opacity1 = isMobile ? 0.6 : 0.7;
                    const opacity2 = isMobile ? 0.4 : 0.5;
                    const opacity3 = isMobile ? 0.5 : 0.6;
                    
                    const angle = (phase * (isMobile ? 5 : 10)) % 360;
                    
                    const pos1 = 35 + (isMobile ? 3 : 5) * Math.sin(phase * (isMobile ? 0.2 : 0.3));
                    const pos2 = 65 + (isMobile ? 3 : 5) * Math.cos(phase * (isMobile ? 0.2 : 0.3));
                    
                    gradient.style.background = `
                        radial-gradient(circle at ${pos1}% ${pos2}%, 
                            rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, ${opacity1}) 0%, 
                            rgba(${oppositeColor.r}, ${oppositeColor.g}, ${oppositeColor.b}, ${opacity2 * 0.2}) 50%, 
                            transparent 70%),
                        radial-gradient(circle at ${pos2}% ${pos1}%, 
                            rgba(${oppositeColor.r}, ${oppositeColor.g}, ${oppositeColor.b}, ${opacity2}) 0%, 
                            rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, ${opacity1 * 0.2}) 50%, 
                            transparent 70%),
                        conic-gradient(from ${angle}deg, 
                            rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, ${opacity3}) 0deg, 
                            rgba(${oppositeColor.r}, ${oppositeColor.g}, ${oppositeColor.b}, ${opacity3}) 180deg, 
                            rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, ${opacity3}) 360deg)
                    `;
                });
                
                requestAnimationFrame(updateGradients);
            }
            
            requestAnimationFrame(updateGradients);
        }

        window.addEventListener('load', createDynamicGradients);
    </script>
</body>
</html>